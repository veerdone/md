## 计算机基础

采用二进制的原因：运算规则简单、速度快,两种状态分明、可靠性高，便于实现逻辑运算

#### 数据的单位

| 单位 | 表示 | 描述                                                        |
| ---- | ---- | ----------------------------------------------------------- |
| 位   | bit  | 计算机最小的数据单位                                        |
| 字节 | Byte | 计算机中表示存储空间大小的基本单位，8位作为一个字节         |
| 字   | word | 计算机一次能够处理的二进制位的长度，字长64位，由8个字节组成 |

| 数制     | 数码                            | 基数 | 位权 | 后缀 |
| -------- | ------------------------------- | ---- | ---- | ---- |
| 十进制   | 0,1,2,3,4,5,6,7,8,9             | 10   | 10^i | D    |
| 二进制   | 0,1                             | 2    | 2^i  | B    |
| 八进制   | 0,1,2,3,4,5,6,7,                | 8    | 8^i  | Q    |
| 十六进制 | 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F | 16   | 16^i | H    |



#### 进制转换

非十进制转换成十进制：按权展开发
$$
1011.01B = 1\times2^3 + 0\times2^2 + 1\times2^1 + 1\times2^0 + 0\times2^{-1} + 1\times2^{-2}=8+0+2+1+0+0.25=11.25
$$

$$
246Q = 2\times8^2 + 4\times8^1 + 6\times8^0 = 128+32+6=166D
$$

$$
1A5.7H = 1\times16^2 + 10\times16^1 + 5\times16^0 + 7\times16^{-1} = 256+160+0.4375 = 421.4375D
$$

十进制转换成非十进制：整数部分**除基取余法**，小数部分**乘基取整法**

八进制转二进制
$$
236.25Q = 010 011 110.010 101B = 10011110.010101B
$$
二进制转八进制
$$
10110101.0101011B = 010 110 101.010 101 100B = 265.254Q
$$
十六进制转二进制
$$
3DF.8AH = 0011 1101 1111.1000 1010B = 1111011111.1000101B
$$
二进制转十六进制
$$
10110101.0101011B = 1011 0101.0101 0110B = B5.56H
$$

#### 原码、反码、补码

| 类型 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| 原码 | 首位表示符号，其余表示数值                                   |
| 反码 | 除符号位位，其余数取反，正数的反码是其本身，负数的反码是在原码的基础上，符号位不变，其实各个位取反 |
| 补码 | 反码加1，正数的补码就是其本身，负数的补码是在其反码的基础上加1 |





#### 冯诺依曼体系结构

1. 计算机处理的数据和指令一律用二进制数表示
2. 顺序执行程序，计算机运行过程中，把要执行的程序和处理的数据首先存入主存储器（内存），计算机执行程序时，将自动的并按顺序从主存储器中取出指令一天天执行，这一概念称为顺序执行程序
3. 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成

#### 计算机的硬件组成

1. 运算器

	> 运算器由算数逻辑单元（ALU）、累加器、状态寄存器、通用寄存器组等组成
	>
	> 算数逻辑运算单元（ALU）的基本功能为加、减、乘、除四则运算，与、或、非、一，异或等逻辑运算操作，以及移位、求补等操作
	>
	> 计算机运行时，运算器的操作和操作种类由控制器决定，运算器处理的数据来自存储器，处理后的结果数据通常送回存储器，或暂时寄存在运算器

2. 控制器

	> 控制器是计算机的指挥中枢，用于控制计算机各个部件按照指令的功能要求协同工作。其基本功能是从内存取指令、分析指令和想其他部件发出控制信号。
	>
	> 运算器和控制器在计算机逻辑结构上是两部分，但是在物理结构上与控制器共同组成了CPU的核心部分

3. 存储器

	> 存储器主要用来存储数据和程序，是计算机的记忆单元。基本功能是按照指定位置存入或者取出二进制信息，通常分为内存储器和外存储器。
	>
	> 1. 内存的基本存储单元是字节，计算机为每一个存储单元一个编码，称为内存地址
	>
	> 2. 外存储器用来长期存放程序和数据，如硬盘、U盘等。外存一般只与内存进行数据交换。
	>
	> 	- 内存储器最突出的特点是存储速度快，但是容量小、价格贵
	> 	- 外存储器的特点是容量大、价格低，但是存取速度慢
	> 	- 内存储器用于存放那些立即要用的程序和数据，外存储器用于存放暂时不用带程序和数据
	>
	> 3. Cache存储器
	>
	> 	高速缓冲存储器，是位于CPU与内存间的一种容量较小单速度很高的存储器
	>
	> 	CPU的速度远高于内存，当CPU直接从内存中存取数据时要等待一定时间周期，而Cache则可以保存CPU刚用过或循环使用的一部分数据，如果CPU需要再次使用该部分数据可从Cache中直接调用，这样就避免了重复存取数据，减少了CPU的等待时间，因而提高了系统的效率

4. 输入设备

	>输入设备是向计算机输入数据和信息的设备，是用户和计算机系统之间进行信息交换的主要装置之一

5. 输出设备

	>输出设备是把计算或处理的结果或中间结果以人能识别的各种形式，如数字、符号、字母等表示出来，因此输入输出设备起了人与机器之间进行联系的作用



#### 指令和指令系统

指令系统是计算机硬件的语言系统，也叫机器语言，指计算机所能执行的全部指令的集合，它描述了计算机内全部的控制信息和逻辑判断能力。

不同计算机的指令系统包含的指令种类和数目也不同，一般均包含算数运算符、逻辑运算符、判定和控制型、移位操作型、输入和输出型等指令。



计算机执行指令的执行过程

1. 首先由CPU中的控制器发出输入控制指令，讲程序通过系统的输入设备送入内存储器

2. 然后又发出控制命令给内存储器，按照程序和数据在内存储器中的存放地址，依次取出并将数据送入运算器，控制器向运算器发出运算命令，并将运算后的结果送回内存储器
3. 最后控制器向输出设备发送输出命令，将内存储器的结果经输出设备输出

计算机执行一条指令的过程可以分为几个基本步骤：取指令、分析指令、执行指令。程序反复执行各条指令，知道遇到结束指令，则程序运行结束。









## 计算机网络

#### 分类标准

- 有线网络覆盖的地理范围的大小
	- 局域网（LAN）
	- 城域网（MAN）
	- 广域网（WAN）

#### 网络拓扑结构

- 总线型
	- 结构简单，可靠性高
	- 总线传输距离短，故障诊断困难
- 星型
	- 采用集中式控制，容易重组网络，某一节点出现故障，不影响其他节点的工作
	- 对中心节点的要求较高，因为一旦中心节点出现故障，系统将全部瘫痪
- 环型
	- 网络管理简单，通信设备和线路较为节省
	- 当一个节点出现故障时，整个网络就不能工作，对故障的诊断困难，网络重新配置也比较困难
- 树状
	- 控制线路简单，管理也易于实现，是一种集中分层的管理形式
	- 数据要经过多级传输，系统的响应时间较长，对根节点依赖高
- 网状
	- 具有较高的可靠性
	- 结构复杂，实现起来费用较高，不易管理和维护



#### OSI参考模型

- 应用层
- 表示层
- 会话层
- 传输层
- 网络层
- 数据链路层
- 物理层



#### TCP/IP

是Internet最基本的协议，最Internet国际互联网络的基础。TCP/IP协议实际上是由100多个协议组成的协议簇，并且还在不断的扩充中

采用了4层的层级结构

- 应用层（HTTP、FTP、SMTP、POP）
- 传输层（TPC、UDP）
- 网络层（IP）
- 数据链路层



TPC/IP协议簇

- IP协议
	- 负责在主机间寻址并为数据包设定传送路径。IP数据包中含有发送它的源地址和接收它的目的地址
- TPC协议
	- 面向连接的通信协议，提供的是一种可靠的数据流服务。如HTTP、SMTP、FTP等基于TCP
- UDP协议
	- 是面向无连接的不可靠的通信协议。DHCP，QQ发送消息等采用UDP





#### 数据通信

1. 数据
	- 数据分为模拟数据和数字数据两种，模拟数据是指在某个区间产生的连续值，例如，声音、图形、温度、压力
	- 数据数据指的是取值范围是离散的变量或者数值，数字数据更容易利用计算机进行存储、处理和传输。因此，人们利用不同编码方法讲模拟数据表示为由0和1组成的数字数据
2. 信号
	- 信号是一种可以觉察到脉冲，通过它们可以传达信息。信号是运载数据的工具，是数据的载体，在计算机网络中，一般采用电信号来传输数据，如无线电波、电话网中的电流等。
	- 在计算机网络中，电信号分为**模拟信号**和**数字信号**，两者在一定条件下可以相互转化，两种信号相互转换的设备称为调制解调器。将数字信号通过**调制**转换为模拟信号，而模拟信号通过**解调**转换为数字信号
3. 信道
	- 信道是数据传输的通路，在计算机网络中信道分为**物理信道**和**逻辑信道**。物理信道指用于传输数据信号的物理通路，由传输介质与有关通信设备组成，逻辑信道指在物理信道上传输数据信号的逻辑通道。逻辑信道是人为定义的，表示实际传送的不同种类信息的通道

4. 带宽
	- 是指信道可以传输信号的最高频率和最低频率之差，单位为赫兹（Hz）。当通信线路用来传送数字信号时，带宽就表示数字信道所能传送的最高数据传输速率，单位是bps
5. 误码率
	- 误码率是衡量数据在规定时间内数据传输精确性的指标
	- 误码率=传输中的误码/所传输的总码数×100%
	- 各种不同规格的设备，均有严格的误码率标准，在计算机通信中，误码率一般要求小于`10^-6`,即平均每传输1M bit，允许有1 bit出错



#### IP地址

互联网协议地址缩写为Ip地址。IP地址是互联网中每台主机的标识和寻址依据。如同每个人都有一个唯一的身份证号码，网络中每一台计算机由一个IP地址。

Ip地址分为IPv4和IPv6两个版本，目前32位的Ipv4地址任占主流。

Ipv4版本的IP地址是一个32位的二进制数，通常被分割为4个“8位二进制数”，用“点分十进制”表示为“a.b.c.d”的形式，其中，“a,b,c,d”都是0~255之间的十进制整数



#### IP地址的分类

根据网络规模的大小，IP地址分成A、B、C、D、E五大类，其中A类、B类和C类地址为基本地址。

地址数据中的全0或全1有特殊含义，不能作为普通地址使用。

1. 子网掩码

	作用就是将某个IP地址分成网络地址和主机地址两个部分

2. 默认网关

	是一种网络互联设备，用于连接两个协议不同的网络。通俗来说，网关实质上是一个网络通向其他网络的IP地址。

3. DNS服务器地址

	DNS服务器是将域名转换为IP地址的服务器

	DNS服务器中存储着域名和IP地址的对应列表

	若没有正确的DNS服务器IP地址，则无法通过域名访问相应的网络

4. 域名

	域名用"."将各个子域名分割开来，从右往左分别为：顶级域名-二级域名-三级域名-主机名



## 操作系统

操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件

#### 操作系统的功能和目标

1. 作为系统资源的管理者

	- 提供的功能
		- 处理机管理
		- 存储器管理
		- 文件管理
		- 设备管理
	- 目标
		- 安全、高效

2. 作为用户和计算机硬件之间的接口

	- 提供的功能
		- 命令接口
			- 联机命令接口
			- 脱机命令接口
		- 程序接口
		- GUI（图形用户界面）
	- 目标
		- 方便用户使用

3. 实现对硬件机器的拓展

	没有任何软件支持的计算机称为裸机，在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器



#### 操作系统的特征

- 并发
	- 并发：指两个或多个事件在同一时间间隔内发生，这些事件宏观上是同时发生的，但微观上是交替发生的。
	- 并行：指两个或多个事件在同一时刻同时发生
	- 操作系统的并发性指计算机系统中同时存在着多个运行着的程序
- 共享
	- 共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用
	- 互斥共享方式，系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
	- 同时共享方式，系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问
- 虚拟
	- 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上对应物是用户感受到的
	- 空分复用技术
	- 时分复用技术
- 异步
	- 在多个程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进

并发和共享是两个最基本的特征，两者互为存在条件，

并发性指计算机系统中同时存在着多个运行着的程序

共享性是指系统中的资源可供内存中多个并发执行的进程共同使用



#### 操作系统的运行机制和体系结构

![OS的运行机制和体系结构](https://file.merryeveryday.com/md-picture/md-pictureOS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

#### 指令

- 特权指令，不允许用户程序使用
- 非特权指令

两中处理器状态（用程序状态字寄存器中的某标志位来标识当前处理器处理什么状态）

- 用户态（目态），此时CPU只能执行非特权指令
- 核心态（管态），特权、非特权指令都能执行

两种程序

- 内核程序，操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态
- 应用程序，为了保证系统能完全运行，普通应用程序只能执行非特权指令，运行在用户态



#### 内核

**内核**是计算机上配置的底层**软件**，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是**内核程序**。

- 时钟管理，实现计时功能
- 中断处理，负责实现中断机制
- 原语
	- 一种特殊的程序
	- 处于操作系统最底层，是最接近硬件的部分
	- 这种程序的运行具有原子性
	- 运行时间较短、调用频繁

#### 操作系统的体系结构

大内核

- 将操作系统的主要功能模块都作为系统内核，运行在核心态
- 优点：高性能
- 缺点：内核代码庞大，结构混乱，难以维护

微内核

- 只把最基本的功能保留在内核
- 优点：内核功能少，结构清晰，方便维护
- 缺点：需要频繁的在核心态和用户态之间切换，性能低

#### 中断和异常

中断机制的诞生

实现了多道程序并发执行本质，发生中断就意味着需要操作系统介入，开展管理工作



中断的概念和作用

1. 当中断发生时，CPU立即进入**核心态**
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理

发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。**中断**可以使CPU从**用户态切换为核心态**，**使操作系统获得计算机的控制权**，有了中断，才能实现多道程序并发执行。

用户态->核心态是通过中断实现的，并且**中断**是**唯一途径**。

核心态->用户态的切换是通过**执行一个特权指令**，将程序状态字的标志位设置为用户态。

 

![image-20230117223547643](https://file.merryeveryday.com/md-picture/image-20230117223547643.png)

#### 系统调用

系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊的函数，应用程序可以发出系统调用请求来获得操作系统的服务。

应用程序通过**系统调用**请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以**保证系统的稳定性和安全性**，防止用户进行非法操作。

![image-20230124205326442](https://file.merryeveryday.com/md-picture/image-20230124205326442.png)

系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此**系统调用的相关处理**需要在**核心态**下进行。



### 进程

#### 进程的定义

程序段、数据段、PCB三部分组成了**进程实体（进程映像）**。一般情况下，我们把进程实体就简称为进程，例如，所谓创建进程，实际上是创建了实体中的PCB，而撤销进程，实质上是撤销进程实体中的PCB。

注意：PCB是进程存在的唯一标志

从不同的角度，进程可以有不同的定义，比较传统典型的定义有：

1. 进程是程序的一次**执行过程**
2. 进程是一个程序及其数据在处理机上顺序执行所发生的活动
3. 进程是具有独立功能的程序在数据集合上运行的过程，它是系统资源分配和调度的一个独立单位

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的



#### 进程的组成

进程（进程实体）由程序段、数据段、PCB三个部分组成。

操作系统通过PCB来管理进程，因此PCB中应该包含操作系统对其进行管理所需的各种信息。

程序段存放的是程序代码

数据段存放的是程序运行时使用、产生的运算数据。

![image-20230124212839221](https://file.merryeveryday.com/md-picture/image-20230124212839221.png)

#### 进程的组织

![image-20230124213309044](https://file.merryeveryday.com/md-picture/image-20230124213309044.png)

#### 进程的特征

![image-20230124213919546](https://file.merryeveryday.com/md-picture/image-20230124213919546.png)

#### 进程的状态

![image-20230124215502022](https://file.merryeveryday.com/md-picture/image-20230124215502022.png)

![image-20230124215445924](https://file.merryeveryday.com/md-picture/image-20230124215445924.png)

> 运行态-> 阻塞态 是一种进程自身作出的主动行为
>
> 阻塞态-> 就绪态 不是进程自身能控制的，是一种被动行为
>
> 不能由阻塞态直接转换成运行态，也不能由就绪态直接转换成阻塞态

暂时调到外存等待的进程状态为挂起状态，挂起态又可以进一步分为就绪挂起、阻塞挂起两种状态

#### 进程的控制

进程的控制主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能

实现进程控制

用原语实现进程控制。

原语采用“关中断指令”和“开中断指令”实现，只允许在核心态下执行。

![image-20230124230445700](https://file.merryeveryday.com/md-picture/image-20230124230445700.png)

![image-20230124230500969](https://file.merryeveryday.com/md-picture/image-20230124230500969.png)

![image-20230124230521231](https://file.merryeveryday.com/md-picture/image-20230124230521231.png)

![image-20230124230536933](https://file.merryeveryday.com/md-picture/image-20230124230536933.png)

#### 进程通信

![image-20230125094156388](https://file.merryeveryday.com/md-picture/image-20230125094156388.png)

进程通信就是指进程之间的信息交换。

进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立。为了保证安全，一个进程不能直接访问另一个进程的空间。

##### 共享存储

两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。操作系统只负责提供共享空间和同步互斥工具。

基于数据结构的共享：共享方式速度慢、限制多、是一种**低级通信**方式。

基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都有进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种**高级通信**方式。

##### 管道通信

”管道“是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟出了一个大小固定的缓冲区。

1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输，如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要**互斥**地访问管道。
3. 数据以字符流对形式写入管道，当**管道写满**时，**写进程**的系统调用将**阻塞**，等待读进程将数据取走。当读进程将数据全部取走后，**管道变空**，此时**读进程**的系统调用将被**阻塞**。
4. 如果**没写满，就不允许读**。如果**没读空，就不允许写**。
5. 数据一旦被读出，就从管道中被抛弃，这就意味**读进程最多只能有一个**，否则可能会有读错数据的情况。

##### 消息传递

进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的”发送消息/接收消息“两个原语进行数据交换。

消息由两部分组成：

- 消息头
	- 发送进程ID、接受进程ID、消息类型、消息长度等格式化的消息
- 消息体

消息传递的两种方式：

- 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
- 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称为”信箱通信方式“



#### 什么是线程

可以把线程理解为”轻量级进程“。线程是一个基本的CPU执行单元，也是程序执行流的最小单位。引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务。

引入线程后，**进程**只作为**除CPU之外的系统资源的分配单位**。



#### 线程的属性

![image-20230125102403758](https://file.merryeveryday.com/md-picture/image-20230125102403758.png)





#### 线程的实现方式

- 用户级线程

用户级线程由应用程序通过线程库实现。所有的线程管理工作都由应用程序负责（包括线程切换）

用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。

在用户看来，是有多个线程，但是在操作系统内核看来，并意识不到线程的存在。

”用户级线程“就是”从用户视角看能看到的线程“。

- 内核级线程

内核级线程的管理工作由操作系统内核完成。线程调度、切换等工作都有内核负责，因此内核线程的切换必须需要在核心态下才能完成。

”内核级线程“就是”从操作系统内核视角看能看到的线程”。



#### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了多线程模型问题。



多对一模型：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。

优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。

缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。



一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行。

缺点：一个用户进程会占用多个内核级线程，多线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



多对多模型：n用户级线程映射到m个内核级线程（n>=m）。每个用户进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。



#### 调度

处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给它们分配内存等必要资源，并建立相应的进程（建立PCB），以使其获得竞争处理机的权利。

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



中级调度，引入了虚拟存储技术，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。

这么做的目的是为了提高内存利用率和系统吞吐量。

暂时调到外存等待的进程状态为挂起状态。PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操纵系统会通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到挂起队列中。

中级调度（内存调度），就是要决定哪个处于挂起状态的进程重新调入内存。

一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理级分配给它。

进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。

进程调度的频率很高，一般几十毫秒一次。



#### 进程调度的时机

![image-20230125162648700](https://file.merryeveryday.com/md-picture/image-20230125162648700.png)

![image-20230125162719654](https://file.merryeveryday.com/md-picture/image-20230125162719654.png)



#### 进程调度的方式

非剥夺调度方式，又称非抢占式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞状态。

剥夺调度方式，又称抢占式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。



#### 进程的切换与过程

“狭义的进程调度”与“进程切换”到区别：

狭义的进程调度指的是从就绪队列中选中一个要运行的线程（这个进程可以是刚刚被暂停执行的线程，也可以是另一个线程，有一种情况需要进程切换）。

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤

进程切换的过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复

> 进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在进程切换上，而真正用于执行进程的时间减少。



#### 调度算法的评价指标

![image-20230125181659751](https://file.merryeveryday.com/md-picture/image-20230125181659751.png)

##### CPU利用率

CPU利用率：指CPU忙碌的时间占总时间的占比
$$
利用率 = {忙碌的时间 \over 总时间}
$$

##### 系统吞吐量

系统吞吐量：单位时间内完成作业的数量
$$
系统吞吐量 = {总共完成了多少道作业 \over 总共花了多少时间}
$$


##### 周转时间

周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。

它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。

周转时间 = 作业完成时间 - 作业提交时间
$$
平均周转时间 = {各作业周转时间之和 \over 作业数}
$$

$$
带权周转时间 = {作业周转时间 \over 作业实际运行的时间} = {作业完成时间-作业提交时间 \over 作业实际运行时间}
$$

$$
平均带权周转时间 = {各作业带权周转时间之和 \over 作业数}
$$

##### 等待时间

等待时间，指线程/作业处于等待处理机状态时间之和

对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。

##### 响应时间

响应时间，指从用户提交请求到首次产生响应所用的时间。



#### 调度算法

##### 先来先服务（FCFS，First Come First Serve）

![image-20230125220600432](https://file.merryeveryday.com/md-picture/image-20230125220600432.png)

##### 短作业优先（SJF，Shortest Job First）

![image-20230125222304792](https://file.merryeveryday.com/md-picture/image-20230125222304792.png)

##### 高响应比优先（HRRN， Highest Response Ratio Next）

![image-20230125223109634](https://file.merryeveryday.com/md-picture/image-20230125223109634.png)



##### 时间轮转（RR，Round-Robin）

![image-20230126142923528](https://file.merryeveryday.com/md-picture/image-20230126142923528.png)

##### 优先级调度算法

根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种

静态优先级：创建进程时确定，之后一直不变

动态优先级:创建进程时有一个初始值，之后会根据情况动态地调整优先级

![image-20230126145205187](https://file.merryeveryday.com/md-picture/image-20230126145205187.png)



#### 进程同步

同步亦称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作



#### 进程互斥

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
2. 忙着等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程等待。



#### 进程互斥的软件实现方法

##### 单标志法

两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

可以实现同一时刻最多只允许一个进程访问临界区

存在的问题是：违背了空闲让进原则



##### 双标志先检查法

设置一个布尔型数组，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志设为true，之后开始访问临界区

违反了“忙则等待”原则

##### 双标志后检查法

双标志先检查法是先检查后上锁，从而提出了双标志后检查法，先上锁后检查

双标志后检查法虽然解决了”忙则等待“的问题，但是又违背了”空闲让进“和”有限等待“原则，会因各进程都长期无法访问临界区资源而产生”饥饿“现象



##### Peterson 算法

双标志检查法中，两个进程都争着进入临界区，但是谁也不让着谁，最后谁也无法进入临界区。Gary L.Peterson 想到一个方法，如果双方都争着进入临界区，那么可以让进程尝试”孔融让梨“，主动让对方先使用临界区

解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则



#### 进程互斥的硬件实现方法

##### 中断屏蔽方法

利用“开/关中断指令“实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

优点：简单、高效

缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）



##### TestAndSet指令

简称TS指令，或TestAndLock指令，或TSL指令

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境

缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“



##### Swap指令

又称为Exchange指令、XCHG指令

优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境

缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“



#### 信号量机制

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步

信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某些资源的数量

一对原语：wait(S)原语和signa(S)原语，可以把原语理解为函数，wait和signal是函数名，括号内的信号量S是函数的调用参数

wait、signal原语通常**简称为P、V操作**（来自荷兰语 proberen 和 verhogen）



##### 整型信号量

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量

##### 记录型信号量

整型信号量的缺陷是存在”忙等“问题，因此人们提出了”记录型信号量“，即用记录型数据结构表示的信号量



#### 管程的定义和特征

管程是一种特殊的软件模块，由这些部分组成：

1. 局部于管程的共享数据结构说明
2. 对该数据结构进行操作的一组过程（过程）
3. 对局部于管程的共享数据设置初始值的语句
4. 管程有一个名字



管程的基本特征：

1. 局部于管程的数据只能被局部于管程的过程访问
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
3. 每次仅允许一个进程在管程内执行某个内部过程



#### 死锁

在并发环境下，各进程因竞争资源而造成一方互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，都是"死锁"。



##### 死锁产生的必要条件

互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁

不剥夺条件：进程所获得的资源在未使用完之前，不能由其他线程强行多夺走，只能主动释放

请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程将阻塞，但有又对自己已有的资源保持不放

循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

> 发生死锁时一定有循环等待，但是发生循环等待等待未必死锁



##### 什么时候会发生死锁

1. 对系统资源的竞争。各进程对不可剥夺的资源的竞争可能引起死锁，对可剥夺的资源的竞争不会引起死锁
2. 进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁
3. 信号量的使用不当也会造成死锁



##### 死锁的处理策略

1. 预防死锁
2. 避免死锁
3. 死锁的检测和解除



#### 避免死锁

##### 安全序列

就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。

如果分配率资源之后，系统中找不到任何一个安全序列，系统就进入不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。

如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生了死锁一定是在不安全状态）

因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。





### 内存

#### 什么是内存

内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理。

内存地址从0开始，每个地址对应一个**存储单元**。

如果计算机”**按字节编址**“，则每个存储单元大小为**1字节**，即1B，即8个二进制位

如果字长为16位的计算机”**按字编制**“，则每个存储单元大小为**1个字**，每个字的大小为16个二进制位



#### 写程序到程序运行

- 编译：由编译程序将用户源代码编译成若干个目标模块
- 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- 装入（装载）：由装入程序讲装入模块装入内存运行



装入的三种方式

- 绝对装入

	在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存

	绝对装入只适用于单道程序环境

- 静态重定位

	又称为可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，讲装入模块装入到内存的适当位置。装入时对地址进行”重定位“，将逻辑地址变换为物理地址（地址变化是在装入时一次完成的）

	静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

- 动态重定位

	又称为动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定向寄存器的支持。

	采用动态重定位时允许程序在内存中发生移动。并且可以将程序分配到不连续的存储区中，在程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存，便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间



链接的三种方式

- 静态链接

	在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不在拆开

- 装入时动态链接

	将各目标模块装入内存时，边装入边链接的链接方式

- 运行时动态链接

	在程序执行中需要该目标模块时，才对它进行链接。优点是便于修改和更新，便于实现对目标模块的共享



#### 内存管理

1. 操作系统负责内存空间的分配和回收
2. 操作系统提供某种技术从逻辑上对内存空间进行扩充
3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
4. 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰

![image-20230127195846489](https://file.merryeveryday.com/md-picture/image-20230127195846489.png)

##### 覆盖技术

将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为一个”固定区”和若干个“覆盖区”。

需要常驻内存的段放在“固定区”中，调入后就不在调出（除非运行结束）

必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史



##### 交换技术

交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调整）

具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式，对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的I/O速度比文件区的更快

交换通常在许多进程运行切内存吃紧时进行，而系统负荷降低就暂停。

可优先换出阻塞进程，可换出优先级低的线程，为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间

> PCB会常驻内存。不会被换出外存



#### 单一连续分配

在单一连续分配方式中，内存被分为系统区和用户区。

系统区通常位于内存的低地址部分，用于存放操作系统相关数据，用户区用于存放用户进程相关数据

内存中只有一道用户程序，用户程序独占整个用户区空间。

优点：实现简单，无外部碎片，可以采用覆盖技术扩充内存，不一定需要采取内存保护

缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低



#### 固定内存分配

为了能在内存中装入多道程序，且这些程序之间又互不影响，于是把整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式

分区大小相等，缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合

分区大小不等，增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分

操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态

优点：实现简单，无外部碎片

缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低



#### 动态分区分配

动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，使分区的大小正好适合进程的需要，因此系统分区的大小和数目是可变的

动态分区分配没有内部碎片，但是有外部碎片

内部碎片，分配给某进程的内存区域中，如果有些部分没有用上

外部碎片，是指内存中的某些空闲分区由于太小而难以利用

如果内存中空闲空间的综总和本来可以满足某进程的要求，但是由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求

可以通过紧凑（拼凑，Compaction)技术来解决外部碎片



#### 分页存储管理的基本概念

将内存空间分为一个个大小想等的分区，每个分区就是一个”页框“，或称为”页祯“，”内存块”，”物理块”。每个页框有一个编号，即“页框号”（或者“内存块号”，“页祯号”，“物理块号”）页框号从0开始

讲用户进程的地址空间也分为与页框大小想等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是从0开始的

（进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）

操作系统以页框为单位为每个进程分配内存空间，进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放，也不必按照先后顺序来，可以放到不相邻的各个页框中



#### 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址

通常会在系统中设置一个**页表寄存器（PTR）**，存放页表在内存中的起始地址F和页表长度M

进程未执行时，页表的起始和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中



#### 基本分段存储管理

##### 分段

进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编址

内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻

分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成

> 段号的位数决定了每个进程最多可以分为几个段
>
> 段内地址位数决定了每个段的最大长度是多少

##### 段表

程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称”段表“

每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称”基址“）和段的长度

各个段表项长度是相同的。



#### 分页和分段管理的对比

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的

段是信息都逻辑单位，分段的主要目的是更好的满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息，分段对用户是可见的，用户编程时需要显式地给出段名

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序

分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址

分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址

分段比分页更容易实现信息的共享和保护



#### 分页、分段的优缺点

|          | 优点                                                     | 缺点                                                         |
| -------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| 分页管理 | 内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片 | 不方便按照逻辑模块实现信息的共享和保护                       |
| 分段管理 | 很方便按照逻辑模块实现信息的共享和保护                   | 如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片 |



#### 段页式管理

分段+分页 = 段页式管理

将进程按逻辑模块分段，再将各段分页，再将内存空间分为大小相同等内存块/页框/页祯/物理块

段号的位数决定了每个进程最多可以分为几个段

页号位数决定了每个段最大有多少页

页内偏移量决定了页面大小、内存块大小是多少

每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等，段号是隐含的



#### 虚拟内存

传统存储管理方式的特征、缺点

一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：作业很大时，不能全部装入内存，导致大作业无法运行。当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降

驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源



##### 虚拟内存的定义和特征

基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行

在程序执行过程中，当所访问的信息不在内存中时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存



三个主要特征：

多次性：无需在作业运行时一次性全部装入内存，而是允许被分为多次调入内存

对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出

虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量

> 虚拟内存的实现需要建立在离散分配的内存管理方式基础上



虚拟内存的实现

1. 请求分页存储管理
2. 请求分段存储管理
3. 请求段页式存储管理



##### 请求分页存储管理

请求分页存储管理与基本分页存储管理的主要区别：

在程序执行过程中，打所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存	

请求分页管理方式

- 页表机制
- 缺页中断机构
- 地址变换机构



页表机制

与基本分页管理相比，请求分页管理中，为了实现”请求调页“，操作系统需要知道每个页面是否已经调入内存，如果还没调入，那么也需要知道该页面在外存中存放的位置

当内存空间不够时，要实现”页面置换“，操作系统需要通过某些指标来决定到底换出哪个页面：有的页面没有被修改过，就不用浪费时间写回外存。有点页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否修改的信息



缺页中断机构

在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断

此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项

如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。为修改过的页面不用写回外存

缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断，一条指令在执行期间，可能产生多次缺页中断



地址变换机构

请求分页存储管理与基本分页存储管理的主要区别：

在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序

若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出外存



##### 页面分配、置换策略

驻留集：指请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般不能小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少，驻留集太大，又会导致多道程序并发度下降，资源利用率降低。

固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变。

可变分配：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变。

局部置换：发生缺页时只能选进程自己的物理块进行置换

全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。





固定分配局部置换:系统为每个进程分配一定数量的物理块,在整个运行期间都不改变。若进程在运 行中发生缺页,则只能从该进程在内存中的页面中选出一页换出,然后再调入需要的页面。这种策略 的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可 以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)

可变分配全局置换:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队 列。当某进程发生缺页时,从空闲物理块中取出一块分配给该进程:若已无空闲物理块,则可选择一 个未锁定的页面换出外存,再将该物理块分配给缺页的进程。采用这种策略时,只要某进程发生缺页, 都将获得新的物理块,仅当空闲物理块用完时,系统才选择一个未锁定的页面调出。被选择调出的页 可能是系统中任何一个进程中的页,因此这个被选中的进程拥有的物理块会减少,缺页率会增加。

可变分配局部置换:刚开始会为每个进程分配一定数量的物理:块。当某进程发生缺页时,只允许从该 进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页,系统会为该进程多分配 几个物理块,直至该进程缺页率趋势适当程度;反之,如果进程在运行中缺页率特别低,则可适当减 少分配给该进程的物理块。

可变分配全局置换:只要缺页就给分配新物理块

可变分配局部置换:要根据发生缺页的频率来动态地增加或减少进程的物理块



何时调入页面

1. 预调页策略:根据局部性原理,一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过,则又是低效的。因此可以预测不久之后可能访问到的页面,将它们预先调入内存,但目前预测成功率只有50%左右。故这种策略**主要用于进程的首次调入**,由程序员指出应该先调入哪些部分。

2. 请求调页策略:进程**在运行期间发现缺页时才将所缺页面调入内存**。由这种策略调入的页面一定会被访问到,但由于每次只能调入一页,而每次调页都要磁盘1/0操作,因此I/0开销较大。



何处调入页面

1. 系统拥有足够的对换区空间:页面的调入、调出都是在内存与对换区之间进行,这样可以保证页面的调入、调出速度很快。在进程运行前,需将进程相关的数据从文件区复制到对换区。
2. 系统缺少足够的对换区空间:凡是不会被修改的数据都直接从文件区调入,由于这些页面不会被修改,因此换出时不必写回磁盘,下次需要时再从文件区调入即可。对于可能被修改的部分,换出时需写回磁盘对换区,下次需要时再从对换区调入。
3. UNIX方式:运行之前进程有关的数据全部放在文件区,故未使用过的页面,都可从文件区调入。若被使用过的页面需要换出,则写回对换
	区,下次需要时从对换区调入。



抖动（颠簸）现象

刚刚换出的页面马上又要被换入内存，刚刚换入的页面马上又要被换出外存，这种频繁的页面调度行为称为**抖动**，或**颠簸**。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）



工作集

驻留集：指请求分页存储管理中给进程分配的内存块的集合

工作集：指在某段时间间隔里，进程实际访问页面的集合

工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干个内存块。一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页



### 文件

#### 文件的属性

文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件。

标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称

类型：指明文件的类型

位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）

大小：指明文件大小

创建时间、上次修改时间文件所有者信息

保护信息：对文件进行保护的访问控制信息



无结构文件（如文本文件）--由一些二进制或字符流组成，又称为”流失文件“

有结构文件--由一组相似的记录组成，又称“记录式文件“





#### 文件如何存放在外存

与内存一样，外存也是由一个个存储单元组成的，每个存储单元可以存储一定量的数据。每个存储单元对应一个物理地址。

类似于内存分为一个个”内存块“，外存会分为一个个”块/磁盘块/物理块“。每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址。同样类似的是，文件的逻辑地址也可以分为（逻辑块号，块内地址），操作系统同样需要将逻辑地址转换为外存的物理地址（物理块号，块内地址）的形式。块内地址的位数取决于磁盘块的大小





#### 有结构文件

由一组相似的记录组成，又称”记录式文件“。每条记录由若干个数据项组成。一般来说，每条记录有一个数据项可作为关键字。根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。



#### 有结构文件的逻辑结构

##### 顺序文件

文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

顺序存储：逻辑上相邻的记录，物理上也相邻

链式存储：逻辑上相邻的记录物理上不一定相邻

![image-20230129195258805](https://file.merryeveryday.com/md-picture/image-20230129195258805.png)

定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取，若能再保证记录的顺序结构，则可以实现快速检索（即根据关键字快速找到对应记录）



##### 索引文件

索引表本身是定长记录的顺序文件。因此可以快速找到第1个记录对应的索引项。可将关键字作为索引号内容,若按关键字顺序排列,则还可以支持按照关键字折半查找。每当要增加/删除一个记录时,需要对索引表进行修改。由于索引文件有很快的检索速度,因此主要用于对信息处理的及时性要求比较高的场合。
另外,可以用不同的数据项建立多个索引表。



##### 索引顺序文件

若一个顺序文件有10000个记录,则根据关键字检索文件,只能从头开始顺序查找(这里指的并不是定长记录、顺序结构的顺序文件),平均须查找5000个记录。
若采用素引顺序文件结构,可把10000个记录分为V10000=100组,每组100个记录。则需要先顺序查找索引表找到分组(共100个分组,因此索引表长度为100,平均需要查50次),找到分组后,再在分组中顺序查找记录(每个分组100个记录,因此平均需要查50次)。可见,采用索引顺序文件结构后,平均查找次数减少为50+50=100次。



##### 多级索引文件

为了选一步提高检索效率,可以为顺序文件建立多级索引表。例如,对于一个含10^6个记录的文件,可先为该文件建立一张低级索引表,每100个记录为一组,故低级索引表中共有10000个表项(即10000个定长记录),再把这10000个定长记录分组,每组100个,为与其建立顶级索引表,故顶级索引表中共有100个表项。



#### 文件的目录

##### 文件控制块

FCB的有序集合称为"文件目录",一个FCB就是一个文件**目录项**。
FCB中包含了文件的**基本信息**(文件名、物理地址、逻辑结构、物2000理结构等),存取控制信息(是否可读/可写、禁止访问的用户名单等),使用信息(如文件的建立时间、修改时间等)。

**最重要、最基本**的还是**文件名、文件存放的物理地址**





##### 目录结构-单级目录结构

单级目录实现了”按名存取“，但是不允许文件重名。

在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中

##### 目录结构-两级目录结构

分为主文件目录和用户文件目录

允许不同用户的文件重名。文件名虽然相同但是对应的其实是不同的文件



##### 目录结构-多级目录结构

又称为树形目录结构

用户要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用”/"隔开。从根目录出发的路径称为绝对路径

树形结构可以很方便的对文件进行分类，层级结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了”无环图目录结构“



##### 目录结构-无环图目录结构

可以用不同的文件名指向同一个文件，甚至可以指向同一个目录

需要为每个共享节点设置一个共享计数器，用于记录此时有多少个地方在共享该节点。用户提出删除节点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享节点

只有共享计数器减为0，才删除节点。

共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那所有用户都可以看到文件数据的变化



##### 索引节点

在查找各级目录的过程中，只需要用到”文件名“这个信息，只有文件名匹配时，才需要读出文件的其他信息，因此可以考虑让目录表”瘦身“来提升效率



#### 文件的物理结构

##### 文件块、磁盘块

在内存管理中，进程的逻辑地址空间分为一个个页面，同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为一个个的文件”块“

于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式



##### 文件分配方式-连续分配

要求每个文件在磁盘上占有一组连续的块

优点：连续分配的文件在**顺序读/写时速度最快**

缺点：

1. 物理上采用连续分配的文件不方便拓展
2. 存储空间利用率低，会产生难以利用的磁盘碎片，可以用紧凑来处理碎片，但是需要消耗很大的时间代价

##### 文件分配方式-链接分配

链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为**隐式链接**和**显式链接**两种



隐式链接

除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针

优点：很方便文件拓展，不会有碎片问题，外存利用率高

缺点：

1. 只支持顺序访问，不支持随机访问，查找效率低
2. 指向下一个盘块的指针也要消耗少量的存储空间



显式链接

把用于链接文件各物理块的指针显式的存放在一张表中，即文件分配表（FAT，File Application Table)。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存。

优点：很方便文件拓展，不会有碎片文件，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高

缺点：文件分配表需要占用一定的存储空间



##### 文件分配方式-索引分配

索引分配允许文件离散地分配在各个磁盘块中,系统会**为每个文件建立一张索引表**,索引表中**记录了文件的各个逻辑块对应的物理块**(索引表的功能类似于内存管理中的页表--建立逻辑页面到物理页之间的映射关系)。索引表存放的磁盘块称为索引块。文件数故据存放的磁盘块称为数据块。

1. 链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放

	缺点：若文件很大，索引表很长，就需要将很多个多饮块链接起来，想要找到i号索引块，必须先依次读入0~i-1号索引块，这就导致磁盘I/O次数过多，查找效率低下

2. 多级索引：建立多层索引。使第一层索引块指向第二层的索引块，还可以根据文件的大小再建立第三层、第四层索引块

	缺点：即使是小文件，访问一个数据块仍然需要K+1次读磁盘

3. 混合索引：多种索引分配方式的结合。例如：一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单向索引表)，还包含两级间接索引（指向两层索引表）

	优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少



#### 文件存储空间管理

##### 存储空间的划分与初始化

存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）

存储空间的初始化：将各个文件卷划分为目录区、文件区

目录区主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息

文件区用于存放文件数据



##### 存储空间管理方法-空闲表法

如何分配磁盘块：与内存管理中的动态分区分配类似，为一个文件分配连续的存储空间，同样**可采用首次适应、最佳适应、最坏适应等算法**来决定要为文件分配哪个区间



##### 存储空间管理-空闲链表法

空闲盘块链-以盘块为单位组成一条空闲链

操作系统保存着链头、链尾指针



空闲盘区链-以盘区为单位组成一条空闲链



##### 存储空间管理-位示图法



##### 存储空间管理-成组链接法





#### 文件的基本操作

##### 创建文件

1. 在外存中找打文件所需的空间
2. 根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息

##### 删除文件

1. 根据文件存放路径找到相应的目录文件,从目录中找到文件名对应的目录项。

2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息,回收文件占用的磁盘块。(回收磁盘块时,根据空闲表法、空闲链表法、位图法等管理策略的不同,需要做不同的处理)
3. 从目录表中删除文件对应的目录项



##### 打开文件

1. 根据文件存放路径找到相应的目录文件,从目录中找到文件名对应的的目录项,并检查该用户是否有指定的操作权限。
2. 将目录项复制到内存中的"打开文件表"中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。



##### 读文件

进程使用read系统调用完成写操作。需要指明是哪个文件(在支持"打开文件"操作的系统中,只需要提供文件在打开文件表中的索引号即可),还需要指明要读入多少数据(如:读入1KB)、指明读入的数据要放在内存中的什么位置。操作系统在处理read系统调用时,会从读指针指向的外存中,将用户指定大小的数据读入用户指定的内存区域中。



##### 写文件

进程使用write系统调用完成写操作,需要指明是哪个文件(在支持"打开文件"操作的系统中,只需要提供文件在打开文件表中的索引号即可),还需要指明要写出多少数据(如:写出1KB)、写回外存的数据放在内存中的什么位置操作系统在处理write系统调用时,会从用户指定的内存区域中,将指定大小的数据写回写指针指向的外存。





#### 文件共享

##### 基于索引节点的共享方式（硬链接）

索引结点中设置一个链接计数变量count,用于表示链接到本索引结点上的用户目录项数。
若count=2,说明此时有两个用户目录项链接到该索引结点上,或者说是有两个用户在共享此文件。
若某个用户决定"删除"该文件,则只是要把用户目录中与该文件对应的目录项删除,且索引结点的count值减1。
若count>0,说明还有别的用户要使用该文件,暂时不能把文件数据删除,否则会导致指针悬空
当count=0时系统负责删除文件。

##### 基于符号链接的共享方式（软链接）







#### 文件保护

##### 口令保护

对文件设置一个口令，用户请求访问该文件时必须提供口令

优点：保存口令的空间开销小，验证口令的时间开销也很小。

缺点：正确的口令存放在系统内部，不够安全



##### 加密保护

使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密

优点：保密性强，不需要在系统中存储密码

缺点：编译/译码，或者说加密/解密需要花费一定时间



##### 访问控制

在每个文件的FCB中增加一个访问控制表，该表中记录了各个用户可以对该文件执行哪些操作





#### 文件系统的层次结构





#### 磁盘的结构

##### 磁盘、磁道、扇区

磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据

磁盘的盘面被划分为一个个磁道

一个磁道又被划分为一个个扇区，每个扇区就是一个磁盘块。每个扇区存放的数据量相同



##### 如何在磁盘中读/写数据

需要把磁头移动到想要读/写的扇区所在的磁道。

磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作



##### 磁盘的物理地址

可用(柱面号,盘面号,扇区号)来定位任意一个"磁盘块"。在"文件的物理结构"小节中,我们经常提到文件数据存放在外存中的几号块,这个块号就可以转换成(柱面号,盘面号,扇区号)的地址形式。
可根据该地址读取一个"块"

1. 根据"柱面号"移动磁臂,让磁头指
	向指定柱面;
2. 激活指定盘面对应的磁头;
3. 磁盘旋转的过程中,指定的扇区会从
	磁头下面划过,这样就完成了对指定扇
	区的读/写。



##### 磁盘的分类

磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道

磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头



盘片是否可更换分为

- 固定盘磁盘
- 可换盘磁盘



#### 磁盘管理

##### 磁盘初始化

Step1:进行低级格式化(物理格式化),将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域(如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分,包括扇区校验码(如奇偶校验、CRC循环冗余校验码等,校验码用于校验扇区中的数据是否发生错误)
Step2:将磁盘分区,每个分区由若干柱面组成(即分为我们们熟悉的C盘、D盘、E盘)
Step3:进行逻辑格式化,创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构(如位示图、空闲分区表)

##### 引导块

计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的



##### 坏块的管理

对于简单的磁盘,可以在逻辑格式化时(建立文件系统时)对整个磁盘进行坏块检查,标明哪些扇区是坏扇区,比如:在FAT表上标明。(在这种方式中,坏块对操作系
统不透明)对于复杂的磁盘,磁盘控制器(磁盘设备内部的一个硬件部件)会维护一个坏块链表。在磁盘出厂前进行低级格式化(物理格式化)时就将坏块链进行初始化。
会保留一些"备用扇区",用于替换坏块。这种方案称为扇区备用。且这种处理方式中,坏块对操作系统透明。





#### I/O设备

##### 什么是I/O设备

”I/O“就是输入/输出（Input/Output）

I/O设备就是将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件

UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作



##### I/O设备的分类-按使用特性

- 人机交互类外部设备 - 数据传输速度慢
- 存储设备 - 数据传输速度快
- 网络通信设备 - 数据传输速度介于上述两者之间



##### I/O设备的分类-按传输速度分类

- 低速设备
- 中速设备
- 高速设备



##### I/O设备的分类-按信息交换的单位分类

- 块设备 - 传输速度较高，可寻址，即对它随机地读/写任一块
- 字符设备 - 传输速度较慢，不可寻址，在输入/输出时常采用中断驱动方式



#### I/O控制器

##### I/O设备的机械部件

I/O设备的机械部件主要用来执行具体I/0操作。
如我们看得见摸得着的鼠标/键盘的按钮;显示器的LED屏;和移动硬盘的磁臂、磁盘盘面。
I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板



##### I/O设备的电子部件（I/O控制器）

CPU无法直接控制I/O设备的机械部件,因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的"中介",用于实现CPU对设备的控制。
这个电子部件就是I/O控制器,又称设备控制器。CPU可控制I/O控制器,又由I/O控制器来控制设备的机械部件。

I/O控制器的功能

- 接受和识别CPU发出的命令
- 向CPU报告设备的状态
- 数据交换
- 地址识别



#### I/O控制方式

##### 程序直接控制方式



