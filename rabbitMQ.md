# MQ

## MQ概述

MQ全程Message Queue（消息队列），是在消息的传输过程中保存消息的容器，多用于分布式系统间进行通信

## MQ优势和劣势

优势

- 应用解耦
- 异步提速
- 削峰填谷

劣势

- 系统可用性降低
- 系统复杂度提高
- 一致性问题

## AMQP

即Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计



## JMS

JMS即java消息服务（JavaMessage Service）应用程序接口，是一个java平台关于面向消息中间件的API





## MQ分类

### ActiveMQ

- 优点：单机吞吐量万级，时效性ms级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据
- 缺点：官方社区对其维护越来越少，高吞吐量场景较少使用

### Kafka

- 优点：性能卓越，单机写入TPS约在百万条/秒，最大优点就是吞吐量高，时效性ms级可用性非常高，Kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用Pull方式获取数据，消息有序，通过控制能够保证所有消息被消费且仅被消费一次，有优秀的第三方Kafka Web管理界面Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用，功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的**实时计算**以及**日志采集**被大规模使用
- 缺点：Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时性却决于轮询间隔时间，消费失败不支持重试，支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢

### RocketMQ

RoeketMQ是阿里巴巴的开源产品，用java实现

- 优点：单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到0丢失，MQ功能较为完善，还是分布式的，扩展性好，支持10亿级别的消息堆积，不会因为堆积导致性能下降，源码是java
- 缺点：支持的客户端语言不多，目前是java及c++，其中c++不成熟，社区活跃度一般，没有在MQ核心中去实现JMS等接口，有些系统要迁移修改大量代码

### RabbitMQ

是一个在AMQP基础上完成的，可复用的企业消息系统

- 优点：由于erlang语言的高并发性，性能较好，吞吐量到万级，MQ功能比较完备，健壮、稳定、易用、跨平台、支持多种语言、开源提供的管理界面非常棒，社区活跃度高，更新频率相当高
- 缺点：商业版需要收费，学习成本较高



## 四大核心概念

### 生产者

产生数据发送消息的程序是生产者

### 交换机

交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中，交换机必须确切知道如何处理它接收的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是将消息丢失，由交换机类型决定

### 队列

队列是RabbitMQ内部使用的一种数据结构，尽管消息流经RabbitMQ和应用程序，但它们只能存储在队列中，队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区，许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。

### 消费者

消费者与接收具有相似的含义，消费者大多时候一个等待接收消息的程序，生产者、消费者和消息中间件很多时候不在同一个机器上，同一个应用程序既可以是生产者又可以是消费者





## 消息应答

消费者在收到消息并且处理该消息后，应告诉rabbitMQ已经处理了，rabbitMQ可以把该消息删除了

### 自动应答

这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用

### 手动应答

```java
Channel.basicAck(用于肯定确定) RabbitMQ已知道该消息并且成功的处理消息，可以将消息丢弃了
Channel.basicNack(用于否定确认)
Channel.basicReject(用于否定确认)
    与Channel.basicNack相比少一个参数
    不处理该消息直接拒绝，可以将其丢弃了
```

手动应答的好处可以批量应答并且减少网络拥堵

### 消息自动重新入队

消费者由于某些原因，导致消息未发送确认，RabbitMQ将了解到消息未完全处理，将对其重新排队，如果此时其他消费者可以处理，它将很快将消息发送给另一个消费者，确保消息不会丢失

## RabbitMQ持久化

在创建队列时将队列指定为持久化，默认保存在内存中，持久化后保存在磁盘中

```java
/*
1.队列名称
2.队列里面的消息是否持久化，默认情况下消息保存在内存中
3.该队列是否只供给一个消费者进行消费，是否消息共享，true可以多个多个消费者消费
4.是否自动删除 最后一个消费者离开连接后，该队列是否自动删除
5.其他参数
*/
channel.queueDeclare(QUEUE_NAME, true, false, false, null);
```



## 不公平分发

RabbitMQ分发消息默认采用的是轮询分发。如需要指定某个消费者处理更多的消息（能者多劳），通过设置**消费者**参数

```java
channel.basicQos(1) // 将参数设置为1，表示不公平分发，默认0表示轮询分发
```

## 预取值

该值定义通道上允许的未确认消息的最大数量

```java
channel.basicQos() // 将参数设置为1以上，表示的是预取值
```

## 发布确认

### 开启发布确认

```java
Channel channel = connection.createChannel();
channel.confirmSelect();
```

### 单个确认发布

是一种简单的确认方式，是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布

这种确认方式的最大缺点就是：**发布速度特别的慢**，最多提供每秒不超过数百条发布消息的吞吐量

### 批量确认发布

先发布一批消息然后一起确认，可以极大的提高吞吐量

缺点：**当发生故障时，不知道是哪个消息出现问题**，必须将整个批处理保存在内存中，以记录重要的消息而后重新发布消息

### 异步确认发布

性价比高，无论是可靠性还是效率都有保证，是利用会回调函数来达到消息可靠性传递的，这个中间件通过函数回调来保证是否投递成功

### 对比

单独发布消息

- 同步等待确认，简单，但吞吐量非常有限

批量发布消息

- 批量同步等待确认，简单、合理的吞吐量，一旦出现问题很难判断出是哪条消息出问题

异步处理

- 最佳性能和资源使用，在出现错误的情况下可以很好的控制，但实现稍微难些

## Exchanges

### 概念

核心思想：生产者生产的消息从不会直接发送到队列。生产者只能将消息发送到交换机。

交换机的工作就是接收来自生产者的消息，将它们推入队列。交换机必须确切知道如何处理收到的消息，是将消息**放到待定队列**还是把它们**放到许多队列**还是**丢弃**。由交换机的类型决定。

### 交换机类型

- 直接(direct)
- 主题(topic)
- 标题(headers)
- 扇出(fanout)
- 不指定的默认--无名类型，用空字符串("")来标识

### 临时队列

一旦断开了消费者的连接，临时队列就会被自动删除

创建方式

```java
String queueName = channel.queueDeclare().getQueue()
```

### 绑定(bingdings)

bindind是交换机和队列之间的桥梁，用于告诉我们交换机和哪个队列进行了绑定关系

### Fanout exchange类型

将接收到的所有消息广播到它的所有队列中

### Direct exchange类型

队列只对它绑定的交换机的消息感兴趣，绑定之后的意义由其交换类型决定

### Topics exchange类型

Topic要求

routing key不能随意写，必须满足一定的要求，必须是一个单词列表，以点号分隔开

- *(星号)可以代替一个单词
- #(井号)可以替代零个或多个单词

当一个队列绑定键是#，那么这个队列将接收所有数据，就像是fanout

如果队列绑定键当中没有#和*出现，那么该队列绑定的类型就是direct

## 死信队列

就是无法被消费的消息，由于某种特定原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信。

### 死信的来源

消息TTL过期

队列达到最大长度(队列满了，无法再添加数据到mq中)

消息被拒绝(basic、reject或basic.nack)并且requeue=false

## 延迟队列

延迟队列其实就是死信队列的消息TTL过期队列

简单来说，延迟队列就是用来存放需要在指定时间被处理元素的队列





## Springboot发布确认

 

